Format(subject to change):
(Log Number) (Date): (Log Subject)
Problem:(Short description of the problem)
Requirements:(List of requirements the solution needs to address)
Dev Notes:(Notes about the process of coming up with the solution, general, not all comprehesive)
Solution:(Short description of the solution, as well as an example of the use case if applicable)
Final Thoughts:(List of potential future problems or improvements, or important information)


0 11/6/2019: Timer Time! (11/4 - 11/6)
Terms: Timer - A object able to handle running code routinely at different intervals on the same thread
Problem: Timers are not something pre-present in c++. Some implementations allow for similar functionality via either system sleep calls or alternate threads. The problem with these are that Sleep calls halt all other processes on the thred until that time has passed, while using other threads causes: async behaviour, abiguity, race conditions, and an overall more complex codebase.
Requirements:
-Needs to be able to handle long and short time frames. Time frames less than 1ms should be possible
-Needs to handle the same time intervals seperately
    e.g. Two timers of the same interval of 1 second should be able to fire at different times
-The timers should be able to fire in an order dictated by the program, aka if multiple timers are ready to fire, the order in which they fire is able to be controlled
-Needs to be able to have modified timescales after creation, either by changing the delay, or adding a time multiplier (Slow motion, hooooo!)
-Should be able to check progress via percentages, milliseconds, and if it should fire
-Pausing and resuming
Dev Notes: Given that high percision is required, chrono will be used to keep track of nanoseconds, while the general input/output will be measured in ms, for percision.
Avoiding all threads and sleeps will allow to keep the use case very simple and easy to use.
Avoid internal measurements of time by keeping a static "CurrentTime" - Posed a challenge for time modification, as you need to work off a modified delay instead of modified internal time, causing a switch. Lower space complexity, larger time complexity(rederiving effective delay instead of modifying tick speed)
Pausing posed some potential space waste, as the duration passed since last tick was not compatable with the time_point stored in LastUpdate, which is ideal for storing the time passed when paused, but it was possible to set the time_point to contain just the duration passed
*** My favorite problem*** Setting a new time modifier was difficult as time passed was not being tracked against a static delay. A dynamic "Effective Delay" made switching the TimeMultiplier not a percentage consistant change when simply updating the multiplier. In order to keep it consistent, the function now also either adds or subtracts time from the "LastUpdate" tracker to maintain the correct percentage when the TimeMultiplier is updated.
An option for manual calls was added, though still under consideration, as it just adds another static field and adds a very small amount of time complexity overall, while only supporting a minor edge case for overall project implementation styles
----------------------------------------------
Solution:The final product is an object that has configurable initial delay, TimeMultiplier, and pause status while adding no new threads or sleep counters to the program. In order to implement a small overhead is nessesary once followed by, a declaration and definition for a timer, and a simple one line implmentation around the code to be run. e.g.

```c++
int main(){
    Timer t = Timer(1000);
    for (int i = 0; i < 10){
        Timer::UpdateTime();    //This line updates the global current time REQUIRED
        if (t.IsTime()){
            i++;
            std::cout << i << " seconds passed." << std::endl;
        }
    }
}
```
Final Thoughts:
-ManualUpdate management option seems unneccessary, as it can change predictable functionality, as well as adds overall time complexity
-Nanosecond tracking is overkill for the intended use of the timer
-Keeping the EffectiveDelay as a seperate variable would help time complexity, at the expense of space complexity(probably shouldn't care about an extra few bytes)
